{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/ekaygabriel/Downloads/trackify-ventures-ui/lib/auth.ts"],"sourcesContent":["import { betterAuth } from \"better-auth\"\nimport { MongoClient } from \"mongodb\"\nimport { mongodbAdapter } from \"better-auth/adapters/mongodb\"\nimport { nextCookies } from \"better-auth/next-js\"\n\n// MongoDB connection\nconst connectionString = process.env.DATABASE_URL || \"mongodb://localhost:27017/trackify-ventures\"\n\n// Extract database name from connection string\nfunction getDatabaseName(connectionString: string): string {\n  try {\n    const url = new URL(connectionString.replace(/^mongodb\\+srv:/, \"mongodb:\"))\n    const pathname = url.pathname\n    // Remove leading slash and get database name\n    const dbName = pathname.split(\"/\")[1]?.split(\"?\")[0] || \"trackify-ventures\"\n    return dbName\n  } catch {\n    // Fallback: try to extract from connection string manually\n    const match = connectionString.match(/\\/([^/?]+)(\\?|$)/)\n    return match ? match[1] : \"trackify-ventures\"\n  }\n}\n\nconst databaseName = getDatabaseName(connectionString)\n\n// Create MongoDB client with proper connection options for Atlas\n// Note: mongodb+srv:// automatically uses TLS, so we don't need to set it explicitly\nconst client = new MongoClient(connectionString, {\n  maxPoolSize: 10,\n  minPoolSize: 2,\n  maxIdleTimeMS: 30000,\n  serverSelectionTimeoutMS: 10000,\n  socketTimeoutMS: 45000,\n  connectTimeoutMS: 10000,\n  retryWrites: true,\n  retryReads: true,\n})\n\n// Global client instance to reuse across requests (Next.js pattern)\nconst globalForMongo = globalThis as unknown as {\n  _mongoClient?: MongoClient\n  _mongoClientPromise?: Promise<MongoClient>\n}\n\nlet clientPromise: Promise<MongoClient>\n\nif (process.env.NODE_ENV === \"development\") {\n  // In development, use a global variable so the client is not recreated on hot reloads\n  if (!globalForMongo._mongoClientPromise) {\n    globalForMongo._mongoClientPromise = client.connect().catch((error) => {\n      console.error(\"Failed to connect to MongoDB:\", error)\n      // Don't throw here, let Better Auth handle it\n      return client\n    })\n  }\n  clientPromise = globalForMongo._mongoClientPromise\n} else {\n  // In production, create connection promise\n  clientPromise = client.connect().catch((error) => {\n    console.error(\"Failed to connect to MongoDB:\", error)\n    return client\n  })\n}\n\n// Initialize connection immediately (non-blocking)\nclientPromise.then((connectedClient) => {\n  globalForMongo._mongoClient = connectedClient\n  console.log(\"MongoDB connected successfully\")\n}).catch((error) => {\n  console.error(\"MongoDB connection error:\", error)\n})\n\n// Get database instance - Better Auth will handle connection when needed\nconst db = client.db(databaseName)\n\nexport const auth = betterAuth({\n  database: mongodbAdapter(db, {\n    client,\n  }),\n  emailAndPassword: {\n    enabled: true,\n    requireEmailVerification: false, // Set to true if you want email verification\n    sendResetPassword: async ({ user, url, token }, request) => {\n      // TODO: Integrate with your email service (Resend, SendGrid, etc.)\n      // For now, we'll log the reset link. In production, send an email.\n      console.log(\"Password reset requested for:\", user.email)\n      console.log(\"Reset URL:\", url)\n      console.log(\"Reset token:\", token)\n      \n      // Example with a real email service:\n      // await sendEmail({\n      //   to: user.email,\n      //   subject: \"Reset your password\",\n      //   html: `\n      //     <h2>Reset Your Password</h2>\n      //     <p>Click the link below to reset your password:</p>\n      //     <a href=\"${url}\">Reset Password</a>\n      //     <p>This link will expire in 1 hour.</p>\n      //   `,\n      // })\n    },\n    onPasswordReset: async ({ user }, request) => {\n      console.log(`Password reset successful for user: ${user.email}`)\n    },\n  },\n  user: {\n    additionalFields: {\n      role: {\n        type: \"string\",\n        required: false,\n        defaultValue: null,\n        input: false, // Don't allow user to set role during signup\n      },\n      onboardingCompleted: {\n        type: \"boolean\",\n        required: false,\n        defaultValue: false,\n        input: false,\n      },\n    },\n  },\n  plugins: [nextCookies()],\n})\n\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;;;AAEA,qBAAqB;AACrB,MAAM,mBAAmB,QAAQ,GAAG,CAAC,YAAY,IAAI;AAErD,+CAA+C;AAC/C,SAAS,gBAAgB,gBAAwB;IAC/C,IAAI;QACF,MAAM,MAAM,IAAI,IAAI,iBAAiB,OAAO,CAAC,kBAAkB;QAC/D,MAAM,WAAW,IAAI,QAAQ;QAC7B,6CAA6C;QAC7C,MAAM,SAAS,SAAS,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,MAAM,IAAI,CAAC,EAAE,IAAI;QACxD,OAAO;IACT,EAAE,OAAM;QACN,2DAA2D;QAC3D,MAAM,QAAQ,iBAAiB,KAAK,CAAC;QACrC,OAAO,QAAQ,KAAK,CAAC,EAAE,GAAG;IAC5B;AACF;AAEA,MAAM,eAAe,gBAAgB;AAErC,iEAAiE;AACjE,qFAAqF;AACrF,MAAM,SAAS,IAAI,sHAAW,CAAC,kBAAkB;IAC/C,aAAa;IACb,aAAa;IACb,eAAe;IACf,0BAA0B;IAC1B,iBAAiB;IACjB,kBAAkB;IAClB,aAAa;IACb,YAAY;AACd;AAEA,oEAAoE;AACpE,MAAM,iBAAiB;AAKvB,IAAI;AAEJ,wCAA4C;IAC1C,sFAAsF;IACtF,IAAI,CAAC,eAAe,mBAAmB,EAAE;QACvC,eAAe,mBAAmB,GAAG,OAAO,OAAO,GAAG,KAAK,CAAC,CAAC;YAC3D,QAAQ,KAAK,CAAC,iCAAiC;YAC/C,8CAA8C;YAC9C,OAAO;QACT;IACF;IACA,gBAAgB,eAAe,mBAAmB;AACpD;;AAQA,mDAAmD;AACnD,cAAc,IAAI,CAAC,CAAC;IAClB,eAAe,YAAY,GAAG;IAC9B,QAAQ,GAAG,CAAC;AACd,GAAG,KAAK,CAAC,CAAC;IACR,QAAQ,KAAK,CAAC,6BAA6B;AAC7C;AAEA,yEAAyE;AACzE,MAAM,KAAK,OAAO,EAAE,CAAC;AAEd,MAAM,OAAO,IAAA,4XAAU,EAAC;IAC7B,UAAU,IAAA,waAAc,EAAC,IAAI;QAC3B;IACF;IACA,kBAAkB;QAChB,SAAS;QACT,0BAA0B;QAC1B,mBAAmB,OAAO,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE;YAC9C,mEAAmE;YACnE,mEAAmE;YACnE,QAAQ,GAAG,CAAC,iCAAiC,KAAK,KAAK;YACvD,QAAQ,GAAG,CAAC,cAAc;YAC1B,QAAQ,GAAG,CAAC,gBAAgB;QAE5B,qCAAqC;QACrC,oBAAoB;QACpB,oBAAoB;QACpB,oCAAoC;QACpC,YAAY;QACZ,mCAAmC;QACnC,0DAA0D;QAC1D,0CAA0C;QAC1C,8CAA8C;QAC9C,OAAO;QACP,KAAK;QACP;QACA,iBAAiB,OAAO,EAAE,IAAI,EAAE,EAAE;YAChC,QAAQ,GAAG,CAAC,CAAC,oCAAoC,EAAE,KAAK,KAAK,EAAE;QACjE;IACF;IACA,MAAM;QACJ,kBAAkB;YAChB,MAAM;gBACJ,MAAM;gBACN,UAAU;gBACV,cAAc;gBACd,OAAO;YACT;YACA,qBAAqB;gBACnB,MAAM;gBACN,UAAU;gBACV,cAAc;gBACd,OAAO;YACT;QACF;IACF;IACA,SAAS;QAAC,IAAA,2YAAW;KAAG;AAC1B"}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///Users/ekaygabriel/Downloads/trackify-ventures-ui/lib/db.ts"],"sourcesContent":["import { MongoClient, Db } from \"mongodb\"\n\nconst connectionString = process.env.DATABASE_URL || \"mongodb://localhost:27017/trackify-ventures\"\n\n// Extract database name from connection string\nfunction getDatabaseName(connectionString: string): string {\n  try {\n    const url = new URL(connectionString.replace(/^mongodb\\+srv:/, \"mongodb:\"))\n    const pathname = url.pathname\n    // Remove leading slash and get database name\n    const dbName = pathname.split(\"/\")[1]?.split(\"?\")[0] || \"trackify-ventures\"\n    return dbName\n  } catch {\n    // Fallback: try to extract from connection string manually\n    const match = connectionString.match(/\\/([^/?]+)(\\?|$)/)\n    return match ? match[1] : \"trackify-ventures\"\n  }\n}\n\nconst databaseName = getDatabaseName(connectionString)\n\n// Create MongoDB client with proper connection options for Atlas\nconst client = new MongoClient(connectionString, {\n  maxPoolSize: 10,\n  minPoolSize: 2,\n  maxIdleTimeMS: 30000,\n  serverSelectionTimeoutMS: 10000,\n  socketTimeoutMS: 45000,\n  connectTimeoutMS: 10000,\n  retryWrites: true,\n  retryReads: true,\n})\n\n// Global client instance to reuse across requests (Next.js pattern)\nconst globalForMongo = globalThis as unknown as {\n  _mongoClient?: MongoClient\n  _mongoClientPromise?: Promise<MongoClient>\n}\n\nlet clientPromise: Promise<MongoClient>\n\nif (process.env.NODE_ENV === \"development\") {\n  // In development, use a global variable so the client is not recreated on hot reloads\n  if (!globalForMongo._mongoClientPromise) {\n    globalForMongo._mongoClientPromise = client.connect().catch((error) => {\n      console.error(\"Failed to connect to MongoDB:\", error)\n      return client\n    })\n  }\n  clientPromise = globalForMongo._mongoClientPromise\n} else {\n  // In production, create connection promise\n  clientPromise = client.connect().catch((error) => {\n    console.error(\"Failed to connect to MongoDB:\", error)\n    return client\n  })\n}\n\n// Initialize connection immediately (non-blocking)\nclientPromise\n  .then((connectedClient) => {\n    globalForMongo._mongoClient = connectedClient\n    console.log(\"MongoDB connected successfully (db.ts)\")\n  })\n  .catch((error) => {\n    console.error(\"MongoDB connection error (db.ts):\", error)\n  })\n\nexport async function getDatabase(): Promise<Db> {\n  try {\n    // Ensure client is connected\n    const connectedClient = await clientPromise\n    // Check if client is still connected, reconnect if needed\n    if (!connectedClient.topology?.isConnected()) {\n      console.warn(\"MongoDB client disconnected, reconnecting...\")\n      await connectedClient.connect()\n    }\n    return connectedClient.db(databaseName)\n  } catch (error) {\n    console.error(\"Error getting database connection:\", error)\n    // Try to reconnect\n    try {\n      await client.close()\n      const newClient = new MongoClient(connectionString, {\n        maxPoolSize: 10,\n        minPoolSize: 2,\n        maxIdleTimeMS: 30000,\n        serverSelectionTimeoutMS: 10000,\n        socketTimeoutMS: 45000,\n        connectTimeoutMS: 10000,\n        retryWrites: true,\n        retryReads: true,\n      })\n      clientPromise = newClient.connect()\n      const connectedClient = await clientPromise\n      return connectedClient.db(databaseName)\n    } catch (reconnectError) {\n      console.error(\"Failed to reconnect to MongoDB:\", reconnectError)\n      throw reconnectError\n    }\n  }\n}\n\n// For cleanup if needed\nexport async function closeDatabase() {\n  try {\n    const connectedClient = await clientPromise\n    await connectedClient.close()\n  } catch (error) {\n    console.error(\"Error closing database connection:\", error)\n  }\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,MAAM,mBAAmB,QAAQ,GAAG,CAAC,YAAY,IAAI;AAErD,+CAA+C;AAC/C,SAAS,gBAAgB,gBAAwB;IAC/C,IAAI;QACF,MAAM,MAAM,IAAI,IAAI,iBAAiB,OAAO,CAAC,kBAAkB;QAC/D,MAAM,WAAW,IAAI,QAAQ;QAC7B,6CAA6C;QAC7C,MAAM,SAAS,SAAS,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,MAAM,IAAI,CAAC,EAAE,IAAI;QACxD,OAAO;IACT,EAAE,OAAM;QACN,2DAA2D;QAC3D,MAAM,QAAQ,iBAAiB,KAAK,CAAC;QACrC,OAAO,QAAQ,KAAK,CAAC,EAAE,GAAG;IAC5B;AACF;AAEA,MAAM,eAAe,gBAAgB;AAErC,iEAAiE;AACjE,MAAM,SAAS,IAAI,sHAAW,CAAC,kBAAkB;IAC/C,aAAa;IACb,aAAa;IACb,eAAe;IACf,0BAA0B;IAC1B,iBAAiB;IACjB,kBAAkB;IAClB,aAAa;IACb,YAAY;AACd;AAEA,oEAAoE;AACpE,MAAM,iBAAiB;AAKvB,IAAI;AAEJ,wCAA4C;IAC1C,sFAAsF;IACtF,IAAI,CAAC,eAAe,mBAAmB,EAAE;QACvC,eAAe,mBAAmB,GAAG,OAAO,OAAO,GAAG,KAAK,CAAC,CAAC;YAC3D,QAAQ,KAAK,CAAC,iCAAiC;YAC/C,OAAO;QACT;IACF;IACA,gBAAgB,eAAe,mBAAmB;AACpD;;AAQA,mDAAmD;AACnD,cACG,IAAI,CAAC,CAAC;IACL,eAAe,YAAY,GAAG;IAC9B,QAAQ,GAAG,CAAC;AACd,GACC,KAAK,CAAC,CAAC;IACN,QAAQ,KAAK,CAAC,qCAAqC;AACrD;AAEK,eAAe;IACpB,IAAI;QACF,6BAA6B;QAC7B,MAAM,kBAAkB,MAAM;QAC9B,0DAA0D;QAC1D,IAAI,CAAC,gBAAgB,QAAQ,EAAE,eAAe;YAC5C,QAAQ,IAAI,CAAC;YACb,MAAM,gBAAgB,OAAO;QAC/B;QACA,OAAO,gBAAgB,EAAE,CAAC;IAC5B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sCAAsC;QACpD,mBAAmB;QACnB,IAAI;YACF,MAAM,OAAO,KAAK;YAClB,MAAM,YAAY,IAAI,sHAAW,CAAC,kBAAkB;gBAClD,aAAa;gBACb,aAAa;gBACb,eAAe;gBACf,0BAA0B;gBAC1B,iBAAiB;gBACjB,kBAAkB;gBAClB,aAAa;gBACb,YAAY;YACd;YACA,gBAAgB,UAAU,OAAO;YACjC,MAAM,kBAAkB,MAAM;YAC9B,OAAO,gBAAgB,EAAE,CAAC;QAC5B,EAAE,OAAO,gBAAgB;YACvB,QAAQ,KAAK,CAAC,mCAAmC;YACjD,MAAM;QACR;IACF;AACF;AAGO,eAAe;IACpB,IAAI;QACF,MAAM,kBAAkB,MAAM;QAC9B,MAAM,gBAAgB,KAAK;IAC7B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sCAAsC;IACtD;AACF"}},
    {"offset": {"line": 274, "column": 0}, "map": {"version":3,"sources":["file:///Users/ekaygabriel/Downloads/trackify-ventures-ui/lib/admin-helpers.ts"],"sourcesContent":["import { auth } from \"@/lib/auth\"\nimport { headers } from \"next/headers\"\nimport { getDatabase } from \"@/lib/db\"\nimport { ObjectId } from \"mongodb\"\n\n// Admin email(s) - in production, store this in environment variables or database\nconst ADMIN_EMAILS = process.env.ADMIN_EMAILS?.split(\",\") || []\n\nexport async function isAdmin(): Promise<boolean> {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    })\n\n    if (!session || !session.user.email) {\n      return false\n    }\n\n    // Check if user email is in admin list\n    if (ADMIN_EMAILS.includes(session.user.email)) {\n      return true\n    }\n\n    // Also check database for admin role\n    const db = await getDatabase()\n    let user = null\n\n    if (ObjectId.isValid(session.user.id)) {\n      user = await db.collection(\"user\").findOne({ _id: new ObjectId(session.user.id) })\n    }\n\n    if (!user && session.user.email) {\n      user = await db.collection(\"user\").findOne({ email: session.user.email })\n    }\n\n    // Check if user has admin role\n    return user?.role === \"admin\" || user?.isAdmin === true\n  } catch (error) {\n    console.error(\"Error checking admin status:\", error)\n    return false\n  }\n}\n\nexport async function requireAdmin() {\n  const admin = await isAdmin()\n  if (!admin) {\n    throw new Error(\"Unauthorized: Admin access required\")\n  }\n  return true\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,kFAAkF;AAClF,MAAM,eAAe,QAAQ,GAAG,CAAC,YAAY,EAAE,MAAM,QAAQ,EAAE;AAExD,eAAe;IACpB,IAAI;QACF,MAAM,UAAU,MAAM,qHAAI,CAAC,GAAG,CAAC,UAAU,CAAC;YACxC,SAAS,MAAM,IAAA,4QAAO;QACxB;QAEA,IAAI,CAAC,WAAW,CAAC,QAAQ,IAAI,CAAC,KAAK,EAAE;YACnC,OAAO;QACT;QAEA,uCAAuC;QACvC,IAAI,aAAa,QAAQ,CAAC,QAAQ,IAAI,CAAC,KAAK,GAAG;YAC7C,OAAO;QACT;QAEA,qCAAqC;QACrC,MAAM,KAAK,MAAM,IAAA,0HAAW;QAC5B,IAAI,OAAO;QAEX,IAAI,mHAAQ,CAAC,OAAO,CAAC,QAAQ,IAAI,CAAC,EAAE,GAAG;YACrC,OAAO,MAAM,GAAG,UAAU,CAAC,QAAQ,OAAO,CAAC;gBAAE,KAAK,IAAI,mHAAQ,CAAC,QAAQ,IAAI,CAAC,EAAE;YAAE;QAClF;QAEA,IAAI,CAAC,QAAQ,QAAQ,IAAI,CAAC,KAAK,EAAE;YAC/B,OAAO,MAAM,GAAG,UAAU,CAAC,QAAQ,OAAO,CAAC;gBAAE,OAAO,QAAQ,IAAI,CAAC,KAAK;YAAC;QACzE;QAEA,+BAA+B;QAC/B,OAAO,MAAM,SAAS,WAAW,MAAM,YAAY;IACrD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO;IACT;AACF;AAEO,eAAe;IACpB,MAAM,QAAQ,MAAM;IACpB,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT"}},
    {"offset": {"line": 333, "column": 0}, "map": {"version":3,"sources":["file:///Users/ekaygabriel/Downloads/trackify-ventures-ui/app/api/admin/analytics/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { requireAdmin } from \"@/lib/admin-helpers\"\nimport { getDatabase } from \"@/lib/db\"\n\nexport async function GET(request: NextRequest) {\n  try {\n    await requireAdmin()\n\n    const db = await getDatabase()\n\n    // Get total users\n    const totalUsers = await db.collection(\"user\").countDocuments({})\n\n    // Get users by role\n    const usersByRole = await db\n      .collection(\"user\")\n      .aggregate([\n        {\n          $group: {\n            _id: \"$role\",\n            count: { $sum: 1 },\n          },\n        },\n      ])\n      .toArray()\n\n    // Get onboarding completion stats\n    const onboardingStats = await db\n      .collection(\"user\")\n      .aggregate([\n        {\n          $group: {\n            _id: \"$onboardingCompleted\",\n            count: { $sum: 1 },\n          },\n        },\n      ])\n      .toArray()\n\n    // Get users created in last 30 days\n    const thirtyDaysAgo = new Date()\n    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)\n\n    const recentUsers = await db.collection(\"user\").countDocuments({\n      createdAt: { $gte: thirtyDaysAgo },\n    })\n\n    // Get users created in last 7 days\n    const sevenDaysAgo = new Date()\n    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7)\n\n    const newUsersThisWeek = await db.collection(\"user\").countDocuments({\n      createdAt: { $gte: sevenDaysAgo },\n    })\n\n    // Get signups over time (last 30 days, grouped by day)\n    const signupsOverTime = await db\n      .collection(\"user\")\n      .aggregate([\n        {\n          $match: {\n            createdAt: { $gte: thirtyDaysAgo },\n          },\n        },\n        {\n          $group: {\n            _id: {\n              $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" },\n            },\n            count: { $sum: 1 },\n          },\n        },\n        {\n          $sort: { _id: 1 },\n        },\n      ])\n      .toArray()\n\n    // Get active sessions (users with recent activity)\n    const activeSessions = await db.collection(\"session\").countDocuments({\n      expiresAt: { $gt: new Date() },\n    })\n\n    // Get users by onboarding status\n    const completedOnboarding = onboardingStats.find((stat) => stat._id === true)?.count || 0\n    const pendingOnboarding = onboardingStats.find((stat) => stat._id === false || stat._id === null)?.count || 0\n\n    // Format role stats\n    const roleStats = usersByRole.reduce(\n      (acc, stat) => {\n        acc[stat._id || \"none\"] = stat.count\n        return acc\n      },\n      {} as Record<string, number>\n    )\n\n    return NextResponse.json({\n      success: true,\n      analytics: {\n        totalUsers,\n        newUsersThisWeek,\n        recentUsers,\n        activeSessions,\n        usersByRole: {\n          investor: roleStats.investor || 0,\n          founder: roleStats.founder || 0,\n          none: roleStats.none || 0,\n        },\n        onboarding: {\n          completed: completedOnboarding,\n          pending: pendingOnboarding,\n          completionRate: totalUsers > 0 ? ((completedOnboarding / totalUsers) * 100).toFixed(1) : \"0\",\n        },\n        signupsOverTime: signupsOverTime.map((item) => ({\n          date: item._id,\n          count: item.count,\n        })),\n      },\n    })\n  } catch (error) {\n    console.error(\"Error fetching analytics:\", error)\n    if (error instanceof Error && error.message.includes(\"Unauthorized\")) {\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 403 })\n    }\n    return NextResponse.json({ error: \"Failed to fetch analytics\" }, { status: 500 })\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}