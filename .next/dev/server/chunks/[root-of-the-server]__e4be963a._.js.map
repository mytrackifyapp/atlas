{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/ekaygabriel/Downloads/trackify-ventures-ui/lib/auth.ts"],"sourcesContent":["import { betterAuth } from \"better-auth\"\nimport { MongoClient } from \"mongodb\"\nimport { mongodbAdapter } from \"better-auth/adapters/mongodb\"\nimport { nextCookies } from \"better-auth/next-js\"\n\n// MongoDB connection\nconst connectionString = process.env.DATABASE_URL || \"mongodb://localhost:27017/trackify-ventures\"\n\n// Extract database name from connection string\nfunction getDatabaseName(connectionString: string): string {\n  try {\n    const url = new URL(connectionString.replace(/^mongodb\\+srv:/, \"mongodb:\"))\n    const pathname = url.pathname\n    // Remove leading slash and get database name\n    const dbName = pathname.split(\"/\")[1]?.split(\"?\")[0] || \"trackify-ventures\"\n    return dbName\n  } catch {\n    // Fallback: try to extract from connection string manually\n    const match = connectionString.match(/\\/([^/?]+)(\\?|$)/)\n    return match ? match[1] : \"trackify-ventures\"\n  }\n}\n\nconst databaseName = getDatabaseName(connectionString)\n\n// Create MongoDB client with proper connection options for Atlas\n// Note: mongodb+srv:// automatically uses TLS, so we don't need to set it explicitly\nconst client = new MongoClient(connectionString, {\n  maxPoolSize: 10,\n  minPoolSize: 2,\n  maxIdleTimeMS: 30000,\n  serverSelectionTimeoutMS: 10000,\n  socketTimeoutMS: 45000,\n  connectTimeoutMS: 10000,\n  retryWrites: true,\n  retryReads: true,\n})\n\n// Global client instance to reuse across requests (Next.js pattern)\nconst globalForMongo = globalThis as unknown as {\n  _mongoClient?: MongoClient\n  _mongoClientPromise?: Promise<MongoClient>\n}\n\nlet clientPromise: Promise<MongoClient>\n\nif (process.env.NODE_ENV === \"development\") {\n  // In development, use a global variable so the client is not recreated on hot reloads\n  if (!globalForMongo._mongoClientPromise) {\n    globalForMongo._mongoClientPromise = client.connect().catch((error) => {\n      console.error(\"Failed to connect to MongoDB:\", error)\n      // Don't throw here, let Better Auth handle it\n      return client\n    })\n  }\n  clientPromise = globalForMongo._mongoClientPromise\n} else {\n  // In production, create connection promise\n  clientPromise = client.connect().catch((error) => {\n    console.error(\"Failed to connect to MongoDB:\", error)\n    return client\n  })\n}\n\n// Initialize connection immediately (non-blocking)\nclientPromise.then((connectedClient) => {\n  globalForMongo._mongoClient = connectedClient\n  console.log(\"MongoDB connected successfully\")\n}).catch((error) => {\n  console.error(\"MongoDB connection error:\", error)\n})\n\n// Get database instance - Better Auth will handle connection when needed\nconst db = client.db(databaseName)\n\nexport const auth = betterAuth({\n  database: mongodbAdapter(db, {\n    client,\n  }),\n  emailAndPassword: {\n    enabled: true,\n    requireEmailVerification: false, // Set to true if you want email verification\n  },\n  user: {\n    additionalFields: {\n      role: {\n        type: \"string\",\n        required: false,\n        defaultValue: null,\n        input: false, // Don't allow user to set role during signup\n      },\n      onboardingCompleted: {\n        type: \"boolean\",\n        required: false,\n        defaultValue: false,\n        input: false,\n      },\n    },\n  },\n  plugins: [nextCookies()],\n})\n\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;;;AAEA,qBAAqB;AACrB,MAAM,mBAAmB,QAAQ,GAAG,CAAC,YAAY,IAAI;AAErD,+CAA+C;AAC/C,SAAS,gBAAgB,gBAAwB;IAC/C,IAAI;QACF,MAAM,MAAM,IAAI,IAAI,iBAAiB,OAAO,CAAC,kBAAkB;QAC/D,MAAM,WAAW,IAAI,QAAQ;QAC7B,6CAA6C;QAC7C,MAAM,SAAS,SAAS,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,MAAM,IAAI,CAAC,EAAE,IAAI;QACxD,OAAO;IACT,EAAE,OAAM;QACN,2DAA2D;QAC3D,MAAM,QAAQ,iBAAiB,KAAK,CAAC;QACrC,OAAO,QAAQ,KAAK,CAAC,EAAE,GAAG;IAC5B;AACF;AAEA,MAAM,eAAe,gBAAgB;AAErC,iEAAiE;AACjE,qFAAqF;AACrF,MAAM,SAAS,IAAI,sHAAW,CAAC,kBAAkB;IAC/C,aAAa;IACb,aAAa;IACb,eAAe;IACf,0BAA0B;IAC1B,iBAAiB;IACjB,kBAAkB;IAClB,aAAa;IACb,YAAY;AACd;AAEA,oEAAoE;AACpE,MAAM,iBAAiB;AAKvB,IAAI;AAEJ,wCAA4C;IAC1C,sFAAsF;IACtF,IAAI,CAAC,eAAe,mBAAmB,EAAE;QACvC,eAAe,mBAAmB,GAAG,OAAO,OAAO,GAAG,KAAK,CAAC,CAAC;YAC3D,QAAQ,KAAK,CAAC,iCAAiC;YAC/C,8CAA8C;YAC9C,OAAO;QACT;IACF;IACA,gBAAgB,eAAe,mBAAmB;AACpD;;AAQA,mDAAmD;AACnD,cAAc,IAAI,CAAC,CAAC;IAClB,eAAe,YAAY,GAAG;IAC9B,QAAQ,GAAG,CAAC;AACd,GAAG,KAAK,CAAC,CAAC;IACR,QAAQ,KAAK,CAAC,6BAA6B;AAC7C;AAEA,yEAAyE;AACzE,MAAM,KAAK,OAAO,EAAE,CAAC;AAEd,MAAM,OAAO,IAAA,4XAAU,EAAC;IAC7B,UAAU,IAAA,waAAc,EAAC,IAAI;QAC3B;IACF;IACA,kBAAkB;QAChB,SAAS;QACT,0BAA0B;IAC5B;IACA,MAAM;QACJ,kBAAkB;YAChB,MAAM;gBACJ,MAAM;gBACN,UAAU;gBACV,cAAc;gBACd,OAAO;YACT;YACA,qBAAqB;gBACnB,MAAM;gBACN,UAAU;gBACV,cAAc;gBACd,OAAO;YACT;QACF;IACF;IACA,SAAS;QAAC,IAAA,2YAAW;KAAG;AAC1B"}},
    {"offset": {"line": 151, "column": 0}, "map": {"version":3,"sources":["file:///Users/ekaygabriel/Downloads/trackify-ventures-ui/lib/db.ts"],"sourcesContent":["import { MongoClient, Db } from \"mongodb\"\n\nconst connectionString = process.env.DATABASE_URL || \"mongodb://localhost:27017/trackify-ventures\"\n\n// Extract database name from connection string\nfunction getDatabaseName(connectionString: string): string {\n  try {\n    const url = new URL(connectionString.replace(/^mongodb\\+srv:/, \"mongodb:\"))\n    const pathname = url.pathname\n    // Remove leading slash and get database name\n    const dbName = pathname.split(\"/\")[1]?.split(\"?\")[0] || \"trackify-ventures\"\n    return dbName\n  } catch {\n    // Fallback: try to extract from connection string manually\n    const match = connectionString.match(/\\/([^/?]+)(\\?|$)/)\n    return match ? match[1] : \"trackify-ventures\"\n  }\n}\n\nconst databaseName = getDatabaseName(connectionString)\n\n// Create MongoDB client with proper connection options for Atlas\nconst client = new MongoClient(connectionString, {\n  maxPoolSize: 10,\n  minPoolSize: 2,\n  maxIdleTimeMS: 30000,\n  serverSelectionTimeoutMS: 10000,\n  socketTimeoutMS: 45000,\n  connectTimeoutMS: 10000,\n  retryWrites: true,\n  retryReads: true,\n})\n\n// Global client instance to reuse across requests (Next.js pattern)\nconst globalForMongo = globalThis as unknown as {\n  _mongoClient?: MongoClient\n  _mongoClientPromise?: Promise<MongoClient>\n}\n\nlet clientPromise: Promise<MongoClient>\n\nif (process.env.NODE_ENV === \"development\") {\n  // In development, use a global variable so the client is not recreated on hot reloads\n  if (!globalForMongo._mongoClientPromise) {\n    globalForMongo._mongoClientPromise = client.connect().catch((error) => {\n      console.error(\"Failed to connect to MongoDB:\", error)\n      return client\n    })\n  }\n  clientPromise = globalForMongo._mongoClientPromise\n} else {\n  // In production, create connection promise\n  clientPromise = client.connect().catch((error) => {\n    console.error(\"Failed to connect to MongoDB:\", error)\n    return client\n  })\n}\n\n// Initialize connection immediately (non-blocking)\nclientPromise\n  .then((connectedClient) => {\n    globalForMongo._mongoClient = connectedClient\n    console.log(\"MongoDB connected successfully (db.ts)\")\n  })\n  .catch((error) => {\n    console.error(\"MongoDB connection error (db.ts):\", error)\n  })\n\nexport async function getDatabase(): Promise<Db> {\n  try {\n    // Ensure client is connected\n    const connectedClient = await clientPromise\n    // Check if client is still connected, reconnect if needed\n    if (!connectedClient.topology?.isConnected()) {\n      console.warn(\"MongoDB client disconnected, reconnecting...\")\n      await connectedClient.connect()\n    }\n    return connectedClient.db(databaseName)\n  } catch (error) {\n    console.error(\"Error getting database connection:\", error)\n    // Try to reconnect\n    try {\n      await client.close()\n      const newClient = new MongoClient(connectionString, {\n        maxPoolSize: 10,\n        minPoolSize: 2,\n        maxIdleTimeMS: 30000,\n        serverSelectionTimeoutMS: 10000,\n        socketTimeoutMS: 45000,\n        connectTimeoutMS: 10000,\n        retryWrites: true,\n        retryReads: true,\n      })\n      clientPromise = newClient.connect()\n      const connectedClient = await clientPromise\n      return connectedClient.db(databaseName)\n    } catch (reconnectError) {\n      console.error(\"Failed to reconnect to MongoDB:\", reconnectError)\n      throw reconnectError\n    }\n  }\n}\n\n// For cleanup if needed\nexport async function closeDatabase() {\n  try {\n    const connectedClient = await clientPromise\n    await connectedClient.close()\n  } catch (error) {\n    console.error(\"Error closing database connection:\", error)\n  }\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,MAAM,mBAAmB,QAAQ,GAAG,CAAC,YAAY,IAAI;AAErD,+CAA+C;AAC/C,SAAS,gBAAgB,gBAAwB;IAC/C,IAAI;QACF,MAAM,MAAM,IAAI,IAAI,iBAAiB,OAAO,CAAC,kBAAkB;QAC/D,MAAM,WAAW,IAAI,QAAQ;QAC7B,6CAA6C;QAC7C,MAAM,SAAS,SAAS,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,MAAM,IAAI,CAAC,EAAE,IAAI;QACxD,OAAO;IACT,EAAE,OAAM;QACN,2DAA2D;QAC3D,MAAM,QAAQ,iBAAiB,KAAK,CAAC;QACrC,OAAO,QAAQ,KAAK,CAAC,EAAE,GAAG;IAC5B;AACF;AAEA,MAAM,eAAe,gBAAgB;AAErC,iEAAiE;AACjE,MAAM,SAAS,IAAI,sHAAW,CAAC,kBAAkB;IAC/C,aAAa;IACb,aAAa;IACb,eAAe;IACf,0BAA0B;IAC1B,iBAAiB;IACjB,kBAAkB;IAClB,aAAa;IACb,YAAY;AACd;AAEA,oEAAoE;AACpE,MAAM,iBAAiB;AAKvB,IAAI;AAEJ,wCAA4C;IAC1C,sFAAsF;IACtF,IAAI,CAAC,eAAe,mBAAmB,EAAE;QACvC,eAAe,mBAAmB,GAAG,OAAO,OAAO,GAAG,KAAK,CAAC,CAAC;YAC3D,QAAQ,KAAK,CAAC,iCAAiC;YAC/C,OAAO;QACT;IACF;IACA,gBAAgB,eAAe,mBAAmB;AACpD;;AAQA,mDAAmD;AACnD,cACG,IAAI,CAAC,CAAC;IACL,eAAe,YAAY,GAAG;IAC9B,QAAQ,GAAG,CAAC;AACd,GACC,KAAK,CAAC,CAAC;IACN,QAAQ,KAAK,CAAC,qCAAqC;AACrD;AAEK,eAAe;IACpB,IAAI;QACF,6BAA6B;QAC7B,MAAM,kBAAkB,MAAM;QAC9B,0DAA0D;QAC1D,IAAI,CAAC,gBAAgB,QAAQ,EAAE,eAAe;YAC5C,QAAQ,IAAI,CAAC;YACb,MAAM,gBAAgB,OAAO;QAC/B;QACA,OAAO,gBAAgB,EAAE,CAAC;IAC5B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sCAAsC;QACpD,mBAAmB;QACnB,IAAI;YACF,MAAM,OAAO,KAAK;YAClB,MAAM,YAAY,IAAI,sHAAW,CAAC,kBAAkB;gBAClD,aAAa;gBACb,aAAa;gBACb,eAAe;gBACf,0BAA0B;gBAC1B,iBAAiB;gBACjB,kBAAkB;gBAClB,aAAa;gBACb,YAAY;YACd;YACA,gBAAgB,UAAU,OAAO;YACjC,MAAM,kBAAkB,MAAM;YAC9B,OAAO,gBAAgB,EAAE,CAAC;QAC5B,EAAE,OAAO,gBAAgB;YACvB,QAAQ,KAAK,CAAC,mCAAmC;YACjD,MAAM;QACR;IACF;AACF;AAGO,eAAe;IACpB,IAAI;QACF,MAAM,kBAAkB,MAAM;QAC9B,MAAM,gBAAgB,KAAK;IAC7B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sCAAsC;IACtD;AACF"}},
    {"offset": {"line": 253, "column": 0}, "map": {"version":3,"sources":["file:///Users/ekaygabriel/Downloads/trackify-ventures-ui/app/api/user/update-role/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { auth } from \"@/lib/auth\"\nimport { headers } from \"next/headers\"\nimport { getDatabase } from \"@/lib/db\"\n\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await auth.api.getSession({\n      headers: await headers(),\n    })\n\n    if (!session) {\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 })\n    }\n\n    const body = await request.json()\n    const { role } = body\n\n    if (!role || (role !== \"investor\" && role !== \"founder\")) {\n      return NextResponse.json({ error: \"Invalid role\" }, { status: 400 })\n    }\n\n    // Get database connection\n    const db = await getDatabase()\n    const dbName = db.databaseName\n    console.log(\"Update role - Database:\", dbName, \"User ID:\", session.user.id, \"Email:\", session.user.email)\n\n    // Better Auth with MongoDB uses _id as primary key\n    // Try _id first (this is what Better Auth uses)\n    let userBefore = null\n    try {\n      const { ObjectId } = await import(\"mongodb\")\n      if (ObjectId.isValid(session.user.id)) {\n        userBefore = await db.collection(\"user\").findOne({ _id: new ObjectId(session.user.id) })\n        if (userBefore) {\n          console.log(\"Found user by _id\")\n        }\n      }\n    } catch (e) {\n      console.error(\"Error trying ObjectId query:\", e)\n    }\n    \n    // If not found by _id, try by email\n    if (!userBefore && session.user.email) {\n      console.log(\"User not found by _id, trying email\")\n      userBefore = await db.collection(\"user\").findOne({ email: session.user.email })\n      if (userBefore) {\n        console.log(\"Found user by email\")\n      }\n    }\n    \n    // Last resort: try id field\n    if (!userBefore) {\n      userBefore = await db.collection(\"user\").findOne({ id: session.user.id })\n    }\n    \n    if (!userBefore) {\n      // List sample users for debugging\n      const sampleUsers = await db.collection(\"user\").find({}).limit(3).toArray()\n      console.error(\"User not found. Database:\", dbName)\n      console.error(\"Session user ID:\", session.user.id)\n      console.error(\"Session user email:\", session.user.email)\n      console.error(\"Sample users in database:\", sampleUsers.map(u => ({ \n        id: u.id, \n        _id: u._id?.toString(), \n        email: u.email \n      })))\n      \n      return NextResponse.json(\n        { error: \"User not found in database\", database: dbName },\n        { status: 404 }\n      )\n    }\n    \n    console.log(\"Found user:\", { id: userBefore.id, _id: userBefore._id?.toString(), email: userBefore.email })\n\n    // Use _id for the update (MongoDB primary key)\n    const { ObjectId } = await import(\"mongodb\")\n    const queryFilter = { _id: userBefore._id }\n    \n    console.log(\"Updating user with filter:\", queryFilter)\n    \n    // Update user role and mark onboarding as completed\n    const result = await db.collection(\"user\").updateOne(\n      queryFilter,\n      {\n        $set: {\n          role,\n          onboardingCompleted: true,\n          updatedAt: new Date(),\n        },\n      }\n    )\n\n    console.log(\"Update result:\", {\n      matchedCount: result.matchedCount,\n      modifiedCount: result.modifiedCount,\n      upsertedCount: result.upsertedCount,\n      upsertedId: result.upsertedId\n    })\n\n    // Verify the update was successful\n    if (result.matchedCount === 0) {\n      console.error(\"User not found in database for update:\", {\n        userId: session.user.id,\n        queryFilter\n      })\n      return NextResponse.json(\n        { error: \"User not found\" },\n        { status: 404 }\n      )\n    }\n\n    // Verify the update was actually saved by reading it back using the same filter\n    const updatedUser = await db.collection(\"user\").findOne(queryFilter)\n    \n    if (!updatedUser) {\n      console.error(\"User not found after update:\", {\n        userId: session.user.id,\n        queryFilter\n      })\n      return NextResponse.json(\n        { error: \"User not found after update\" },\n        { status: 500 }\n      )\n    }\n    \n    if (updatedUser.role !== role || !updatedUser.onboardingCompleted) {\n      console.error(\"Update verification failed:\", {\n        userId: session.user.id,\n        expectedRole: role,\n        actualRole: updatedUser.role,\n        expectedOnboarding: true,\n        actualOnboarding: updatedUser.onboardingCompleted,\n        updatedUser: {\n          _id: updatedUser._id?.toString(),\n          email: updatedUser.email,\n          role: updatedUser.role,\n          onboardingCompleted: updatedUser.onboardingCompleted\n        }\n      })\n      return NextResponse.json(\n        { error: \"Update verification failed - fields not updated correctly\" },\n        { status: 500 }\n      )\n    }\n\n    console.log(\"User update result:\", {\n      userId: session.user.id,\n      role,\n      matchedCount: result.matchedCount,\n      modifiedCount: result.modifiedCount,\n      verified: true\n    })\n\n    return NextResponse.json({ \n      success: true, \n      role,\n      onboardingCompleted: true,\n      matchedCount: result.matchedCount,\n      modifiedCount: result.modifiedCount\n    })\n  } catch (error) {\n    console.error(\"Error updating user role:\", error)\n    return NextResponse.json(\n      { error: \"Failed to update role\" },\n      { status: 500 }\n    )\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}